<!DOCTYPE>
<html>
	<head>
		<title>Prototype</title>
		<script type="text/javascript" src="three.min.js"></script>
        <script type="text/javascript" src="https://rawgit.com/mrdoob/stats.js/master/build/stats.min.js"></script>
        <script type="text/javascript" src="dat.gui.min.js"></script>
		<script type="text/javascript">
		
            // SETUP
			var renderer, scene, camera;
			var lookAt = new THREE.Vector3(0.0, 0.0, 0.0);
			var viewerPosition = new THREE.Vector3(10.0, 10.0, 20.0);
            
            // SHADERS AND TEXTURES
            var vertexShader, fragmentShader;
            var textureY = new THREE.TextureLoader().load( 'Grass1.jpg' );
            var textureX = new THREE.TextureLoader().load( 'Brick.jpg' );
            var textureZ = new THREE.TextureLoader().load( 'Brick.jpg' );
            
            // STATS
            var stats = new Stats();
            stats.showPanel( 0 );
            
            // DEBUG
            var debugGeometry = new THREE.SphereGeometry( 0.1, 20, 20 );
            var debugCategories = {
                hexCentres: new THREE.Group(),
                regularTriplets: new THREE.Group(),
                cliffTriplets: new THREE.Group(),
                regularEdges: new THREE.Group(),
                cliffEdges: new THREE.Group()
            }
            
            // STUFF
            var hexes = [];
            var hexArray = [];
            
            var triplets = [];
            var tripletArray = [];
            
            var edges = [];
            var edgeArray = [];
            
            // UI
            var dragging = false;
            var prevX = 0;
            var prevY = 0;
            var horAngle = 0;
            var vertAngle = 0;
		
			function onLoad() { 
				var canvasContainer = document.getElementById('myCanvasContainer');
                document.body.appendChild( stats.dom );
                
				var width = 1200; 
				var height = 800;
				
                renderer = new THREE.WebGLRenderer(); 
                renderer.setSize(width, height);
                canvasContainer.appendChild(renderer.domElement);
                
				camera = new THREE.PerspectiveCamera( 30, width/height, 0.01, 1000 );
				camera.position.set(viewerPosition.x, viewerPosition.y, viewerPosition.z);
				camera.up = new THREE.Vector3(0, 1, 0);
				camera.lookAt(lookAt);
                
                vertexShader = document.getElementById('vertexShader').textContent;
				fragmentShader = document.getElementById('fragmentShader').textContent;
                
                textureY.wrapS = THREE.RepeatWrapping;
                textureY.wrapT = THREE.RepeatWrapping;
                textureZ.wrapS = THREE.RepeatWrapping;
                textureZ.wrapT = THREE.RepeatWrapping;
                textureX.wrapS = THREE.RepeatWrapping;
                textureX.wrapT = THREE.RepeatWrapping;
                
                scene = new THREE.Scene();
                
                var hex_width = 2;
                var hex_height = 1.73;
                
                var rows = 17;
                var ver_offset = (rows-1)/2*hex_height;
                
                for (var i = 0; i < rows; i++) {
                    var row_hexes = []
                    
                    var hexes_in_row = 2+Math.min(i, rows-i-1)
                    var hor_offset = (hexes_in_row-1)/2*hex_width;
                    
                    for (var j = 0; j < hexes_in_row; j++) {
                        var active = j > 0 & j < (hexes_in_row-1);
                        var hex = createHex(new THREE.Vector3(j*hex_width-hor_offset, Math.random()*2, i*hex_height-ver_offset), active);
                        row_hexes.push(hex);
                    }
                    hexes.push(row_hexes);
                }
                
                hexes[1][2].centre.y = 2;
                hexes[1][2].debugModel.position.y = 2;
                
                hexes[3][2].centre.y = 2;
                hexes[3][2].debugModel.position.y = 2;
                
                hexes[3][3].centre.y = -1;
                hexes[3][3].debugModel.position.y = -1;
                
                // NEIGHBOURS INIT
                for (var row = 1; row < hexes.length-1; row++) {
                    for (var i = 1; i < hexes[row].length-1; i++) {
                        if (row < (rows-1)/2) {
                            createShape(hexes[row][i], [ hexes[row][i-1], hexes[row-1][i-1], hexes[row-1][i], hexes[row][i+1], hexes[row+1][i+1], hexes[row+1][i] ]);
                        } else if (row > (rows-1)/2) {
                            createShape(hexes[row][i], [ hexes[row][i-1], hexes[row-1][i], hexes[row-1][i+1], hexes[row][i+1], hexes[row+1][i], hexes[row+1][i-1] ]);
                        } else {
                            createShape(hexes[row][i], [ hexes[row][i-1], hexes[row-1][i-1], hexes[row-1][i], hexes[row][i+1], hexes[row+1][i], hexes[row+1][i-1] ]);
                        }
                    }
                }
                
                // EDGES
                for (var row = 1; row < hexes.length-1; row++) {
                    var i = 0;
                    
                    if (row < (rows-1)/2) {
                        createShape(hexes[row][i], [ hexes[row-1][i], hexes[row][i+1], hexes[row+1][i+1], hexes[row+1][i] ]);
                    } else if (row > (rows-1)/2) {
                        createShape(hexes[row][i], [ hexes[row-1][i], hexes[row-1][i+1], hexes[row][i+1], hexes[row+1][i] ]);
                    } else {
                        createShape(hexes[row][i], [ hexes[row-1][i], hexes[row][i+1], hexes[row+1][i] ]);
                    }
                    
                    var i = hexes[row].length-1;
                    
                    if (row < (rows-1)/2) {
                        createShape(hexes[row][i], [ hexes[row][i-1], hexes[row-1][i-1], hexes[row+1][i+1], hexes[row+1][i] ]);
                    } else if (row > (rows-1)/2) {
                        createShape(hexes[row][i], [ hexes[row][i-1], hexes[row-1][i], hexes[row-1][i+1], hexes[row+1][i-1] ]);
                    } else {
                        createShape(hexes[row][i], [ hexes[row][i-1], hexes[row-1][i-1], hexes[row+1][i-1] ]);
                    }
                }
                
                // TOP/BOTTOM
                var row = 0;
                var i = 0;
                createShape(hexes[row][i], [ hexes[row][i+1], hexes[row+1][i+1], hexes[row+1][i] ]);
                var row = 0;
                var i = 1;
                createShape(hexes[row][i], [ hexes[row][i-1], hexes[row+1][i+1], hexes[row+1][i] ]);
                var row = hexes.length-1;
                var i = 0;
                createShape(hexes[row][i], [ hexes[row-1][i], hexes[row-1][i+1], hexes[row][i+1] ]);
                var row = hexes.length-1;
                var i = 1;
                createShape(hexes[row][i], [ hexes[row][i-1], hexes[row-1][i-1], hexes[row-1][i] ]);
                
                generateEdges();
                generateTriplets();
                finishEdges();
                
                var terrainGeom = createTerrainGeometry();
                terrainGeom.computeVertexNormals();
                
                var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
                directionalLight.position.set(10.11, 10, 10)
                scene.add( directionalLight );
                
                var uniforms = {
                    lightPosition: new THREE.Uniform(directionalLight.position),
                    color: new THREE.Uniform(new THREE.Vector3(1.0,1.0,1.0)),
                    texY: new THREE.Uniform(textureY),
                    texX: new THREE.Uniform(textureX),
                    texZ: new THREE.Uniform(textureZ),
                }
                
                uniforms = THREE.UniformsUtils.merge( [
                    uniforms,
                    THREE.UniformsLib[ "lights" ]
                ] );
                
                uniforms.texY.value.needsUpdate = true;
                uniforms.texX.value.needsUpdate = true;
                uniforms.texZ.value.needsUpdate = true;
                
                var material = new THREE.ShaderMaterial( {
                    color: 0xffffff,
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    uniforms: uniforms,
                    lights:true
                } );
                var mesh = new THREE.Mesh( terrainGeom, material );
                scene.add(mesh);
                
                
                for (cat in debugCategories) {
                    scene.add(debugCategories[cat])
                    debugCategories[cat].visible = !debugCategories[cat].visible;
                }
                
                
                renderer.domElement.addEventListener( 'mousedown', event => {
                    dragging = true;
                    prevX = event.offsetX;
                    prevY = event.offsetY;
                }, false );
                renderer.domElement.addEventListener( 'mouseup', event => dragging = false, false );
                renderer.domElement.addEventListener( 'mousemove', event => {
                    if (dragging) {
                        horAngle -= (event.offsetX-prevX)/40
                        vertAngle -= (event.offsetY-prevY)/40
                        
                        if (vertAngle < 0.000001)
                            vertAngle = 0.000001;
                        if (vertAngle > Math.PI)
                            vertAngle = Math.PI;

                        prevX = event.offsetX;
                        prevY = event.offsetY;
                    }
                }, false );
                
                createGUI();
				draw();
			}
            
            function createDebugSphere(position, color, category) {
                var material = new THREE.MeshBasicMaterial( { color: color } );
                var mesh = new THREE.Mesh( debugGeometry, material );
                mesh.position.copy( position );
                debugCategories[category].add(mesh)
                return mesh;
            }
            
            function generateTriplets() {
                for (var i = 0; i < latestID; i++) {
                    triplets.push([])
                }
                
                for (hex of hexArray) {
                    if (!hex.active)
                        continue;
                    
                    generateHexTriplets(hex);
                }
            }
            
            function generateHexTriplets(hex) {
                var j = 0;
                for (var i = 0; i < hex.neighbours.length; i++) {
                    j = (i+1) % hex.neighbours.length;
                    
                    tri = getTriplet(hex, hex.neighbours[i], hex.neighbours[j], generate=true)
                }
            }
            
            function getTriplet(a,b,c, generate=false) {
                if (a.isHex)
                    a = a.id;
                if (b.isHex)
                    b = b.id;
                if (c.isHex)
                    c = c.id;
                
                if (a > b) {
                    a = b + (b=a, 0)
                }
                if (b > c) {
                    c = b + (b=c, 0)
                    
                    if (a > b) {
                        a = b + (b=a, 0)
                    }
                }
                
                for (p of triplets[a]) {
                    if (p.b == b && p.c == c) {
                        return p;
                    }
                }
                if (generate) {
                    var n = generateTriplet(hexArray[a],hexArray[b],hexArray[c]);
                    triplets[a].push(n)
                    return n;
                } else
                    throw new Error("Triplet " + [a,b,c] + " not found.")
            }
            
            var triplet_id = 0;
            var triplet_vertex_index = 0;
            function generateTriplet(a,b,c) {
                var triplet = {a:a.id,b:b.id,c:c.id};
                triplet.id = triplet_id++;
                triplet.vertex_index = triplet_vertex_index;
                tripletArray.push(triplet);
                
                triplet.position =  a.centre.clone().add(b.centre).add(c.centre).divideScalar(3);
                
                var ab = getEdge(a,b);
                var bc = getEdge(c,b);
                var ac = getEdge(c,a);
                
                ab.triplets.push(triplet);
                bc.triplets.push(triplet);
                ac.triplets.push(triplet);
                
                var vertices = {}
                
                if (ab.cliff & bc.cliff & ac.cliff) {
                    triplet.a_pos = triplet.position.clone().setComponent(1, a.centre.y);
                    triplet.b_pos = triplet.position.clone().setComponent(1, b.centre.y);
                    triplet.c_pos = triplet.position.clone().setComponent(1, c.centre.y);
                    
                    triplet.a_pos.index = triplet_vertex_index++;
                    triplet.b_pos.index = triplet_vertex_index++;
                    triplet.c_pos.index = triplet_vertex_index++;
                    
                    var upper = Math.max(a.centre.y+b.centre.y, b.centre.y+c.centre.y, a.centre.y+c.centre.y)/2;
                    var lower = Math.min(a.centre.y+b.centre.y, b.centre.y+c.centre.y, a.centre.y+c.centre.y)/2;
                    
                    triplet.upper_mid = triplet.position.clone().setComponent(1, upper);
                    triplet.lower_mid = triplet.position.clone().setComponent(1, lower);
                    
                    triplet.upper_mid.index = triplet_vertex_index++;
                    triplet.lower_mid.index = triplet_vertex_index++;
                    triplet.mid = triplet.lower_mid;
                    
                    vertices[a.id] = triplet.a_pos;
                    vertices[b.id] = triplet.b_pos;
                    vertices[c.id] = triplet.c_pos;
                    
                    triplet.triple_cliff = true;
                    
                    triplet.vertArr = [triplet.a_pos, triplet.b_pos, triplet.c_pos, triplet.upper_mid, triplet.lower_mid];
                    
                    createDebugSphere(triplet.a_pos, 0xff0000, "cliffTriplets");
                    createDebugSphere(triplet.b_pos, 0xff0000, "cliffTriplets" );
                    createDebugSphere(triplet.c_pos, 0xff0000, "cliffTriplets" );
                } else if (ab.cliff & bc.cliff) {
                    triplet.a_pos = triplet.position.clone().setComponent(1, (a.centre.y+c.centre.y)/2 );
                    triplet.b_pos = triplet.position.clone().setComponent(1, b.centre.y);
                    triplet.c_pos = triplet.a_pos;
                    
                    triplet.mid = triplet.a_pos.clone().add(triplet.b_pos).divideScalar(2);
                    
                    triplet.a_pos.index = triplet_vertex_index++;
                    triplet.b_pos.index = triplet_vertex_index++;
                    triplet.mid.index = triplet_vertex_index++;
                    
                    vertices[a.id] = triplet.a_pos;
                    vertices[b.id] = triplet.b_pos;
                    vertices[c.id] = triplet.c_pos;
                    
                    triplet.vertArr = [triplet.a_pos, triplet.b_pos, triplet.mid];
                    
                    createDebugSphere(triplet.a_pos, 0xff0000, "cliffTriplets" );
                    createDebugSphere(triplet.b_pos, 0xff0000, "cliffTriplets" );
                    createDebugSphere(triplet.mid, 0xff0000, "cliffTriplets" );
                } else if (ab.cliff & ac.cliff) {
                    triplet.a_pos = triplet.position.clone().setComponent(1, a.centre.y);
                    triplet.b_pos = triplet.position.clone().setComponent(1, (b.centre.y+c.centre.y)/2 );
                    triplet.c_pos = triplet.b_pos;
                    
                    triplet.mid = triplet.a_pos.clone().add(triplet.b_pos).divideScalar(2);
                    
                    triplet.a_pos.index = triplet_vertex_index++;
                    triplet.b_pos.index = triplet_vertex_index++;
                    triplet.mid.index = triplet_vertex_index++;
                    
                    vertices[a.id] = triplet.a_pos;
                    vertices[b.id] = triplet.b_pos;
                    vertices[c.id] = triplet.c_pos;
                    
                    triplet.vertArr = [triplet.a_pos, triplet.b_pos, triplet.mid];
                    
                    createDebugSphere(triplet.a_pos, 0xff0000, "cliffTriplets" );
                    createDebugSphere(triplet.b_pos, 0xff0000, "cliffTriplets" );
                    createDebugSphere(triplet.mid, 0xff0000, "cliffTriplets" );
                } else if (bc.cliff & ac.cliff) {
                    triplet.a_pos = triplet.position.clone().setComponent(1, (a.centre.y+b.centre.y)/2 );
                    triplet.b_pos = triplet.a_pos;
                    triplet.c_pos = triplet.position.clone().setComponent(1, c.centre.y);
                    
                    triplet.mid = triplet.a_pos.clone().add(triplet.c_pos).divideScalar(2);
                    
                    triplet.a_pos.index = triplet_vertex_index++;
                    triplet.c_pos.index = triplet_vertex_index++;
                    triplet.mid.index = triplet_vertex_index++;
                    
                    vertices[a.id] = triplet.a_pos;
                    vertices[b.id] = triplet.b_pos;
                    vertices[c.id] = triplet.c_pos;
                    
                    triplet.vertArr = [triplet.a_pos, triplet.c_pos, triplet.mid];
                    
                    createDebugSphere(triplet.a_pos, 0xff0000, "cliffTriplets" );
                    createDebugSphere(triplet.c_pos, 0xff0000, "cliffTriplets" );
                    createDebugSphere(triplet.mid, 0xff0000, "cliffTriplets" );
                } else {
                    triplet.a_pos = triplet.position;
                    triplet.b_pos = triplet.position;
                    triplet.c_pos = triplet.position;
                    triplet.mid = triplet.position;
                    
                    triplet.position.index = triplet_vertex_index++;
                    
                    vertices[a.id] = triplet.a_pos;
                    vertices[b.id] = triplet.b_pos;
                    vertices[c.id] = triplet.c_pos;
                    
                    triplet.vertArr = [triplet.position];
                    
                    createDebugSphere(triplet.position, 0xffff00, "regularTriplets" );
                }
                
                triplet.vertices = vertices;
                
                return triplet;
            }
            
            function generateEdges() {
                for (var i = 0; i < latestID; i++) {
                    edges.push([])
                }
                
                for (hex of hexArray) {
                    for (n of hex.neighbours) {
                        getEdge(hex, n, generate=true);
                    }
                }
            }
            
            function getEdge(a,b, generate = false) {
                if (a.isHex)
                    a = a.id;
                if (b.isHex)
                    b = b.id;
                
                if (a > b) {
                    a = b + (b=a, 0)
                }
                
                for (p of edges[a]) {
                    if (p.b == b) {
                        return p;
                    }
                }
                if (generate) {
                    var e = generateEdge(hexArray[a],hexArray[b]);
                    edges[a].push(e)
                    return e;
                } else
                    throw new Error("Edge " + [a,b] + " not found.")
            }
            
            var edge_id = 0;
            function generateEdge(a,b) {
                var edge = {id:edge_id++, a:a.id, b:b.id, triplets:[]};
                
                for (d of a.neighboursData) {
                    if (d.hex == b) {
                        edge.cliff = d.cliff;
                        break;
                    }
                }
                
                edgeArray.push(edge);
                
                return edge;
            }
            
            var edge_vertex_index = 0;
            function finishEdges() {
                for (edge of edgeArray) {
                    if (!hexArray[edge.a].active & !hexArray[edge.b].active) {
                        continue;
                    }
                    edge.active = true;
                    
                    var a = hexArray[edge.a];
                    var b = hexArray[edge.b];
                    
                    edge.position = edge.triplets[0].vertices[a.id].clone().add(edge.triplets[1].vertices[a.id]).divideScalar(2);
                    
                    edge.vertices = {}
                    edge.vertArr = [];
                    if (edge.cliff) {
                        edge.vertices[a.id] = edge.position.clone().setComponent(1, a.centre.y );
                        edge.vertices[b.id] = edge.position.clone().setComponent(1, b.centre.y );
                        
                        //edge.vertices[a.id].y = (edge.vertices[a.id].y*5 + edge.vertices[b.id].y)/6;
                        //edge.vertices[b.id].y = (edge.vertices[b.id].y*5 + edge.vertices[a.id].y)/6;
                        
                        edge.mid = edge.position.clone().setComponent(1, (a.centre.y+b.centre.y)/2 );
                        
                        edge.vertices[a.id].index = edge_vertex_index++;
                        edge.vertices[b.id].index = edge_vertex_index++;
                        edge.mid.index = edge_vertex_index++;
                        
                        edge.vertArr.push(edge.vertices[a.id], edge.vertices[b.id], edge.mid);
                        
                        createDebugSphere(edge.vertices[a.id], 0x0000ff, "cliffEdges");
                        createDebugSphere(edge.vertices[b.id], 0x0000ff, "cliffEdges");
                        createDebugSphere(edge.mid, 0x0000ff, "cliffEdges");
                    } else {
                        edge.vertices[a.id] = edge.position;
                        edge.vertices[b.id] = edge.position;
                        edge.mid = edge.position;
                        
                        edge.vertices[a.id].index = edge_vertex_index++;
                        edge.vertArr.push(edge.position);
                        
                        createDebugSphere(edge.position, 0x00ffff, "regularEdges");
                    }
                    
                }
            }
            
            var latestID = 0;
            function createHex(centre, active=true) {
                if (latestID == 50) centre.y = 5
                
                var mesh = createDebugSphere(centre, 0xffffff, "hexCentres");
                
                var hex = {id: latestID++, centre: centre, neighbours: [], neighboursData: [], debugModel: mesh, isHex:true, active: active};
                hexArray.push(hex);
                
                
                return hex;
            }
            
            function createTerrainGeometry() {
                var geometry = new THREE.BufferGeometry();
                var vertexArray = [];
                
                // Gather all Vector3 positions
                var vertices = []
                for (hex of hexArray) {
                    vertices.push(hex.centre);
                }
                
                var tri_offset = vertices.length;
                for (triplet of tripletArray) {
                    vertices.push(...triplet.vertArr);
                }
                
                var edge_offset = vertices.length;
                for (edge of edgeArray) {
                    if (!edge.active)
                        continue;
                    
                    vertices.push(...edge.vertArr);
                }
                
                // Create faces
                var faceArray = [];
                for (hex of hexArray) {
                    if (!hex.active)
                        continue;
                    
                    var tri = [];
                    
                    // Collect surrounding triplets
                    for (var i  = 0; i < hex.neighbours.length; i++) {
                        var j = (i+1) % hex.neighbours.length;
                        triplet = getTriplet(hex, hex.neighbours[i], hex.neighbours[j]);
                        var opp_id = hex.neighbours[i].id;
                        
                        // IMPORTANT, DO NOT REMOVE
                        if (triplet.vertices[opp_id].y > triplet.vertices[hex.neighbours[j].id].y)
                            opp_id = hex.neighbours[j].id;
                        
                        tri.push(triplet.vertices[hex.id].index);
                    }
                    
                    var edge = [];
                    
                    // Collect surrounding edges
                    for (n of hex.neighbours) {
                        var n_e = getEdge(hex, n);
                        edge.push(n_e.vertices[hex.id].index);
                    }
                    
                    
                    // Generate extra internal vertices
                    var internal_edge_offset = vertices.length;
                    
                    for (var i = 0; i < tri.length; i++) {
                        var j = (i+1) % tri.length;
                        
                        var dir = hex.centre.clone().sub(vertices[edge_offset+edge[i]]).normalize().multiplyScalar(-0.5);
                        vertices.push(hex.centre.clone().add(dir));
                        //vertices.push(vertices[edge_offset+edge[i]].clone().sub(dir));
                    }
                    
                    var internal_tri_offset = vertices.length;
                    
                    for (var i = 0; i < tri.length; i++) {
                        var j = (i+1) % tri.length;
                        var dir = hex.centre.clone().sub(vertices[tri_offset+tri[i]]).normalize().multiplyScalar(-0.5);
                        vertices.push(hex.centre.clone().add(dir));
                        //vertices.push(vertices[tri_offset+tri[i]].clone().sub(dir));
                    }
                    
                    // Add hex faces
                    for (var i = 0; i < tri.length; i++) {
                        var j = (i+1) % tri.length;
                        
                        faceArray.push(hex.id, internal_tri_offset+i, internal_edge_offset+i);
                        faceArray.push(hex.id, internal_edge_offset+j, internal_tri_offset+i);
                        
                        faceArray.push(internal_edge_offset+j, tri_offset+tri[i], internal_tri_offset+i);
                        faceArray.push(internal_edge_offset+j, edge_offset+edge[j], tri_offset+tri[i]);
                        faceArray.push(internal_tri_offset+i, tri_offset+tri[i], edge_offset+edge[i]);
                        faceArray.push(internal_tri_offset+i, edge_offset+edge[i], internal_edge_offset+i);
                        
                    }
                    
                    // Create cliff faces as neccessary
                    // Facing towards camera, simplest cliff example:
                    // c - a     - associated with hex
                    // |   |
                    // d - b     - associated with opposing hex
                    // edge pointing towards j
                    for (var i  = 0; i < hex.neighbours.length; i++) {
                        var j = (i+1) % hex.neighbours.length;
                        var k = (i+2) % hex.neighbours.length;
                        
                        var triplet1 = getTriplet(hex, hex.neighbours[i], hex.neighbours[j]);
                        
                        var n_e = getEdge(hex, hex.neighbours[j]);
                        
                        var triplet2 = getTriplet(hex, hex.neighbours[j], hex.neighbours[k]);
                        
                        // FIRST SIDE
                        if (!triplet1.triple_cliff | triplet1.vertices[hex.id].y < triplet1.vertices[hex.neighbours[i].id].y) {
                            var a = triplet1.vertices[hex.id];
                            var b = triplet1.vertices[hex.neighbours[j].id];
                            var c = n_e.vertices[hex.id];
                            var d = n_e.vertices[hex.neighbours[j].id];
                            
                            var a_i = tri_offset+a.index;
                            var b_i = tri_offset+b.index;
                            var c_i = edge_offset+c.index;
                            var d_i = edge_offset+d.index;
                            
                            var m1_i = tri_offset+triplet1.mid.index;
                            var m2_i = edge_offset+n_e.mid.index;
                            
                            if (a.y > b.y & c.y > d.y) {
                                faceArray.push(a_i, m2_i, m1_i);
                                faceArray.push(a_i, c_i, m2_i);
                                faceArray.push(m1_i, d_i, b_i);
                                faceArray.push(m1_i, m2_i, d_i);
                            } else if (a.y > b.y & c.y == d.y) {
                                faceArray.push(c_i, m1_i, a_i);
                                faceArray.push(c_i, b_i, m1_i);
                            }  else if (a.y == b.y & c.y > d.y) {
                                faceArray.push(a_i, c_i, m2_i);
                                faceArray.push(a_i, m2_i, d_i);
                            } else if (a.y < b.y & c.y > d.y) {
                                faceArray.push(a_i, m2_i, d_i);
                                faceArray.push(a_i, c_i, m2_i);
                            } else if (a.y > b.y & c.y < d.y) {
                                faceArray.push(c_i, m1_i, a_i);
                                faceArray.push(c_i, b_i, m1_i);
                            }
                        } else if (triplet1.vertices[hex.neighbours[j].id].y > triplet1.vertices[hex.neighbours[i].id].y) {
                            
                            var a = triplet1.vertices[hex.id];
                            var b = triplet1.vertices[hex.neighbours[j].id];
                            var c = n_e.vertices[hex.id];
                            var d = n_e.vertices[hex.neighbours[j].id];
                            
                            var a_i = tri_offset+a.index;
                            var b_i = tri_offset+b.index;
                            var c_i = edge_offset+c.index;
                            var d_i = edge_offset+d.index;
                            
                            var m1_i = tri_offset+triplet1.upper_mid.index;
                            var m2_i = edge_offset+n_e.mid.index;
                            
                            if (a.y > b.y & c.y > d.y) {
                                faceArray.push(a_i, m2_i, m1_i);
                                faceArray.push(a_i, c_i, m2_i);
                                faceArray.push(m1_i, d_i, b_i);
                                faceArray.push(m1_i, m2_i, d_i);
                            } else if (a.y > b.y & c.y == d.y) {
                                faceArray.push(c_i, m1_i, a_i);
                                faceArray.push(c_i, b_i, m1_i);
                            }  else if (a.y == b.y & c.y > d.y) {
                                faceArray.push(a_i, c_i, m2_i);
                                faceArray.push(a_i, m2_i, d_i);
                            } else if (a.y < b.y & c.y > d.y) {
                                faceArray.push(a_i, m2_i, d_i);
                                faceArray.push(a_i, c_i, m2_i);
                            } else if (a.y > b.y & c.y < d.y) {
                                faceArray.push(c_i, m1_i, a_i);
                                faceArray.push(c_i, b_i, m1_i);
                            }
                        } else {
                            var a = tri_offset+triplet1.vertices[hex.id].index;
                            var b = tri_offset+triplet1.vertices[hex.neighbours[j].id].index;
                            var a_b = tri_offset+triplet1.vertices[hex.neighbours[i].id].index;
                            var c = edge_offset+n_e.vertices[hex.id].index;
                            var d = edge_offset+n_e.vertices[hex.neighbours[j].id].index;
                            
                            var u_m = tri_offset+triplet1.upper_mid.index;
                            var l_m = tri_offset+triplet1.lower_mid.index;
                            
                            var m2 = edge_offset+n_e.mid.index;
                            
                            faceArray.push(a, c, u_m);
                            faceArray.push(u_m, c, m2);
                            faceArray.push(u_m, m2, a_b);
                            faceArray.push(a_b, m2, l_m);
                            faceArray.push(l_m, m2, d);
                            faceArray.push(l_m, d, b);
                        }
                        // SECOND SIDE
                        if (!triplet2.triple_cliff | triplet2.vertices[hex.id].y < triplet2.vertices[hex.neighbours[k].id].y) {
                            var a = n_e.vertices[hex.id];
                            var b = n_e.vertices[hex.neighbours[j].id];
                            var c = triplet2.vertices[hex.id];
                            var d = triplet2.vertices[hex.neighbours[j].id];
                            
                            var a_i = edge_offset+a.index;
                            var b_i = edge_offset+b.index;
                            var c_i = tri_offset+c.index;
                            var d_i = tri_offset+d.index;
                            
                            var m1_i = edge_offset+n_e.mid.index;
                            var m2_i = tri_offset+triplet2.mid.index;
                            
                            if (a.y > b.y & c.y > d.y) {
                                faceArray.push(a_i, m2_i, m1_i);
                                faceArray.push(a_i, c_i, m2_i);
                                faceArray.push(m1_i, d_i, b_i);
                                faceArray.push(m1_i, m2_i, d_i);
                            } else if (a.y > b.y & c.y == d.y) {
                                faceArray.push(c_i, m1_i, a_i);
                                faceArray.push(c_i, b_i, m1_i);
                            }  else if (a.y == b.y & c.y > d.y) {
                                faceArray.push(a_i, c_i, m2_i);
                                faceArray.push(a_i, m2_i, d_i);
                            } else if (a.y < b.y & c.y > d.y) {
                                faceArray.push(a_i, m2_i, d_i);
                                faceArray.push(a_i, c_i, m2_i);
                            } else if (a.y > b.y & c.y < d.y) {
                                faceArray.push(c_i, m1_i, a_i);
                                faceArray.push(c_i, b_i, m1_i);
                            }
                        } else if (triplet2.vertices[hex.neighbours[j].id].y > triplet2.vertices[hex.neighbours[k].id].y) {
                            var a = n_e.vertices[hex.id];
                            var b = n_e.vertices[hex.neighbours[j].id];
                            var c = triplet2.vertices[hex.id];
                            var d = triplet2.vertices[hex.neighbours[j].id];
                            
                            var a_i = edge_offset+a.index;
                            var b_i = edge_offset+b.index;
                            var c_i = tri_offset+c.index;
                            var d_i = tri_offset+d.index;
                            
                            var m1_i = edge_offset+n_e.mid.index;
                            var m2_i = tri_offset+triplet2.upper_mid.index;
                            
                            if (a.y > b.y & c.y > d.y) {
                                faceArray.push(a_i, m2_i, m1_i);
                                faceArray.push(a_i, c_i, m2_i);
                                faceArray.push(m1_i, d_i, b_i);
                                faceArray.push(m1_i, m2_i, d_i);
                            } else if (a.y > b.y & c.y == d.y) {
                                faceArray.push(c_i, m1_i, a_i);
                                faceArray.push(c_i, b_i, m1_i);
                            }  else if (a.y == b.y & c.y > d.y) {
                                faceArray.push(a_i, c_i, m2_i);
                                faceArray.push(a_i, m2_i, d_i);
                            } else if (a.y < b.y & c.y > d.y) {
                                faceArray.push(a_i, m2_i, d_i);
                                faceArray.push(a_i, c_i, m2_i);
                            } else if (a.y > b.y & c.y < d.y) {
                                faceArray.push(c_i, m1_i, a_i);
                                faceArray.push(c_i, b_i, m1_i);
                            }
                        } else {
                            var a = edge_offset+n_e.vertices[hex.id].index;
                            var b = edge_offset+n_e.vertices[hex.neighbours[j].id].index;
                            var c = tri_offset+triplet2.vertices[hex.id].index;
                            var d = tri_offset+triplet2.vertices[hex.neighbours[j].id].index;
                            var c_d = tri_offset+triplet2.vertices[hex.neighbours[k].id].index;
                            
                            var u_m = tri_offset+triplet2.upper_mid.index;
                            var l_m = tri_offset+triplet2.lower_mid.index;
                            
                            var m1 = edge_offset+n_e.mid.index;
                            
                            faceArray.push(a, c, u_m);
                            faceArray.push(a, u_m, m1);
                            faceArray.push(m1, u_m, c_d);
                            faceArray.push(m1, c_d, l_m);
                            faceArray.push(m1, l_m, b);
                            faceArray.push(b, l_m, d);
                        }
                    }
                }
                
                
                geometry.setIndex( faceArray );
                
                // Convert to typed array of floats
                for (vertex of vertices) {
                    vertexArray.push(vertex.x, vertex.y, vertex.z);
                }
                vertexArray = new Float32Array(vertexArray);
                
                geometry.setAttribute( 'position', new THREE.BufferAttribute( vertexArray, 3 ) );
                
                return geometry;
            }
            
            function createShape(hex, neighbours) {
                hex.neighbours = neighbours;
                for (neighbours of neighbours) {
                    cliff = false;

                    if (Math.abs(hex.centre.y-neighbours.centre.y) > 0.5) {
                        cliff = true;
                    }
                    
                    if ( ((hex.id+neighbours.id+3)%4) == 0 ) {
                        cliff = false;
                    }
                    
                    if (Math.abs(hex.centre.y-neighbours.centre.y) > 2.5) {
                        cliff = true;
                    }
                    
                    hex.neighboursData.push({hex:neighbours ,cliff: cliff});
                }
            }
            
            function createGUI() {
                var gui = new dat.GUI();
                
                var funcs = {};
                function wrap(cat) {
                    return ()=>{debugCategories[cat].visible = !debugCategories[cat].visible}
                }
                
                for (cat in debugCategories) {
                    funcs[cat] = wrap(cat);
                    gui.add(funcs, cat);
                }
            }
 
			var tick = 0
			function draw() {
                requestAnimationFrame(draw);
                
                stats.begin();
                tick += 1;
                
                camera.position.set(30*Math.sin(horAngle)*Math.sin(vertAngle), 30*Math.cos(vertAngle), 30*Math.cos(horAngle)*Math.sin(vertAngle) );
                camera.lookAt(lookAt);
                
                renderer.render( scene, camera );
                
                stats.end();
			}

		</script>
        <script id="vertexShader" type="x-shader/x-vertex">
			varying vec3 interpolatedPosition; //We interpolate the position
			varying vec3 interpolatedNormal;   //We interpolate the normal
            varying vec3 globalNormal;
            varying vec3 globalPosition;
			
			void main() {
				interpolatedPosition = (modelViewMatrix * vec4(position,1.0)).xyz;
				interpolatedNormal = normalize(normalMatrix * normal);
                globalNormal = normal;
                globalPosition = (modelMatrix * vec4(position,1.0)).xyz;
				
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
			}
		</script>
        <script id="fragmentShader" type="x-shader/x-fragment">
            #if NUM_DIR_LIGHTS > 0
                struct DirectionalLight {
                    vec3 direction;
                    vec3 color;
                    int shadow;
                    float shadowBias;
                    float shadowRadius;
                    vec2 shadowMapSize;
                 };
                 uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
            #endif
        
			uniform vec3 lightPosition;
			uniform vec3 color;
            uniform sampler2D texY;
            uniform sampler2D texX;
            uniform sampler2D texZ;
            
			varying vec3 interpolatedPosition;
			varying vec3 interpolatedNormal;
            
            varying vec3 globalNormal;
            varying vec3 globalPosition;
            
            vec4 gammaTexture2D(sampler2D tex, vec2 uv) {
                return GammaToLinear(texture2D(tex, uv), 2.2);
            }
            
            vec4 gammaTexture2D(sampler2D tex, vec2 uv, float bias) {
                return GammaToLinear(texture2D(tex, uv, bias), 2.2);
            }
			
			void main() {
                vec3 camPos = interpolatedPosition;
                
                vec3 n = normalize(interpolatedNormal);
                
                vec3 viewerDir = normalize(-camPos);
                
                vec3 l = directionalLights[0].direction;
                
                vec3 reflection = reflect(-l, n);
                
                vec3 absNormal = abs(normalize(globalNormal));
                vec3 textureWeights = absNormal/(absNormal.x+absNormal.y+absNormal.z);
                
                vec3 texColor = vec3(0.0);
                texColor += gammaTexture2D(texY, globalPosition.xz/5.0).xyz*textureWeights.y;
                texColor += gammaTexture2D(texX, globalPosition.zy/2.0).xyz*textureWeights.x;
                texColor += gammaTexture2D(texZ, globalPosition.xy/1.0).xyz*textureWeights.z;
                
                vec3 meanX = gammaTexture2D(texX, vec2(0.0), 10.0).xyz;
                vec3 meanY = gammaTexture2D(texY, vec2(0.0), 10.0).xyz;
                vec3 meanZ = gammaTexture2D(texZ, vec2(0.0), 10.0).xyz;
                
                vec3 mean = vec3(0.0);
                mean += meanY*textureWeights.y;
                mean += meanX*textureWeights.x;
                mean += meanZ*textureWeights.z;
                
                vec3 correctedColor = vec3(0.0);
                correctedColor += (gammaTexture2D(texY, globalPosition.xz/5.0).xyz - meanY) * sqrt(textureWeights.y);
                correctedColor += (gammaTexture2D(texX, globalPosition.zy/2.0).xyz - meanX) * sqrt(textureWeights.x);
                correctedColor += (gammaTexture2D(texZ, globalPosition.xy/1.0).xyz - meanZ) * sqrt(textureWeights.z);
                
                float sqweightsum = textureWeights.x*textureWeights.x+textureWeights.y*textureWeights.y+textureWeights.z*textureWeights.z;
                sqweightsum += 2.0*textureWeights.x*textureWeights.z; // remove if x and z textures are not correlated
                
                texColor = (texColor-mean)/sqrt(sqweightsum) + mean;
                
                //texColor = correctedColor+mean;
            
                gl_FragColor = vec4( texColor*0.0 + max(dot(n,l), 0.0)*texColor + pow(max(dot(viewerDir, reflection), 0.0), 2000.0), 1.0);
                
                
                gl_FragColor = LinearToGamma(gl_FragColor, 2.2);
                
                //gl_FragColor.rgb = correctedColor+mean;
                //gl_FragColor.rgb = texColor;
                //gl_FragColor.rgb = vec3(sqweightsum);
			}
		</script>

	</head>
	<body onload="onLoad()">
		<div id="myCanvasContainer"></div>
		<div id="statusContainer">
			<span>Test</span>
			<span>C1</span>
		</div>
	</body>
</html>