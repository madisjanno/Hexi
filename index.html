<!DOCTYPE>
<html>
	<head>
		<title>Prototype</title>
		<script type="text/javascript" src="three.min.js"></script>
        <script type="text/javascript" src="https://rawgit.com/mrdoob/stats.js/master/build/stats.min.js"></script>
        <script type="text/javascript" src="dat.gui.min.js"></script>
		<script type="text/javascript">
		
            // SETUP
			var renderer, scene, camera;
			var lookAt = new THREE.Vector3(0.0, 0.0, 0.0);
			var viewerPosition = new THREE.Vector3(10.0, 10.0, 20.0);
            
            // STATS
            var stats = new Stats();
            stats.showPanel( 0 );
            
            // DEBUG
            var debugGeometry = new THREE.SphereGeometry( 0.1, 20, 20 );
            
            // STUFF
            var hexes = [];
            var hexArray = [];
            
            var triplets = [];
            var tripletArray = [];
            
            var edges = [];
            
            // UI
            var dragging = false;
            var prevX = 0;
            var prevY = 0;
            var horAngle = 0;
            var vertAngle = 0;
		
			function onLoad() { 
				var canvasContainer = document.getElementById('myCanvasContainer');
                document.body.appendChild( stats.dom );
                
				var width = 1200; 
				var height = 800;
				
                renderer = new THREE.WebGLRenderer(); 
                renderer.setSize(width, height);
                canvasContainer.appendChild(renderer.domElement);
                
				camera = new THREE.PerspectiveCamera( 30, width/height, 0.01, 1000 );
				camera.position.set(viewerPosition.x, viewerPosition.y, viewerPosition.z);
				camera.up = new THREE.Vector3(0, 1, 0);
				camera.lookAt(lookAt);
                
                scene = new THREE.Scene();
                
                var hex_width = 2;
                var hex_height = 1.73;
                
                var rows = 17;
                var ver_offset = (rows-1)/2*hex_height;
                
                for (var i = 0; i < rows; i++) {
                    var row_hexes = []
                    
                    var hexes_in_row = 2+Math.min(i, rows-i-1)
                    var hor_offset = (hexes_in_row-1)/2*hex_width;
                    
                    for (var j = 0; j < hexes_in_row; j++) {
                        var hex = createHex(new THREE.Vector3(j*hex_width-hor_offset, Math.random()*2, i*hex_height-ver_offset));
                        row_hexes.push(hex);
                    }
                    hexes.push(row_hexes);
                }
                
                hexes[1][2].centre.y = 2;
                hexes[1][2].debugModel.position.y = 2;
                
                hexes[3][2].centre.y = 2;
                hexes[3][2].debugModel.position.y = 2;
                
                hexes[3][3].centre.y = -1;
                hexes[3][3].debugModel.position.y = -1;
                
                for (var row = 1; row < hexes.length-1; row++) {
                    for (var i = 1; i < hexes[row].length-1; i++) {
                        if (row < (rows-1)/2) {
                            createShape(hexes[row][i], [ hexes[row][i-1], hexes[row-1][i-1], hexes[row-1][i], hexes[row][i+1], hexes[row+1][i+1], hexes[row+1][i] ])
                        } else if (row > (rows-1)/2) {
                            createShape(hexes[row][i], [ hexes[row][i-1], hexes[row-1][i], hexes[row-1][i+1], hexes[row][i+1], hexes[row+1][i], hexes[row+1][i-1] ])
                        } else {
                            createShape(hexes[row][i], [ hexes[row][i-1], hexes[row-1][i-1], hexes[row-1][i], hexes[row][i+1], hexes[row+1][i], hexes[row+1][i-1] ])
                        }
                    }
                }
                
                
                
                
                
                
                generateTriplets();
                
                var terrainGeom = createTerrainGeometry();
                terrainGeom.computeVertexNormals();
                
                var material = new THREE.MeshPhongMaterial( {color: 0xffffff, flatShading:false} );
                var mesh = new THREE.Mesh( terrainGeom, material );
                scene.add(mesh);
                
                var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
                directionalLight.position.set(10, 10, 10)
                scene.add( directionalLight );
                
                
                renderer.domElement.addEventListener( 'mousedown', event => {
                    dragging = true;
                    prevX = event.offsetX;
                    prevY = event.offsetY;
                }, false );
                renderer.domElement.addEventListener( 'mouseup', event => dragging = false, false );
                renderer.domElement.addEventListener( 'mousemove', event => {
                    if (dragging) {
                        horAngle -= (event.offsetX-prevX)/40
                        vertAngle -= (event.offsetY-prevY)/40
                        
                        if (vertAngle < 0.000001)
                            vertAngle = 0.000001;
                        if (vertAngle > Math.PI)
                            vertAngle = Math.PI;

                        prevX = event.offsetX;
                        prevY = event.offsetY;
                    }
                }, false );
                
				draw();
			}
            
            var triplet_vertex_index = 0;
            function generateTriplets() {
                for (var i = 0; i < latestID; i++) {
                    triplets.push([])
                }
                
                for (hex of hexArray) {
                    generateHexTriplets(hex);
                }
            }
            
            function generateHexTriplets(hex) {
                var j = 0;
                for (var i = 0; i < hex.neighbours.length; i++) {
                    j = (i+1) % hex.neighbours.length;
                    
                    tri = getTriplet(hex, hex.neighbours[i], hex.neighbours[j], generate=true)
                    if (tri.ready)
                        continue;
                    tri.ready = true;
                    tri.position =  hex.centre.clone().add(hex.neighbours[i].centre).add(hex.neighbours[j].centre).divideScalar(3);
                    tri.id = triplet_vertex_index++;
                    tripletArray.push(tri);
                    
                    var material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
                    var mesh = new THREE.Mesh( debugGeometry, material );
                    
                    mesh.position.copy( tri.position );
                    
                    //scene.add(mesh)
                }
            }
            
            function getTriplet(a,b,c, generate=false) {
                if (a.isHex)
                    a = a.id;
                if (b.isHex)
                    b = b.id;
                if (c.isHex)
                    c = c.id;
                
                if (a > b) {
                    a = b + (b=a, 0)
                }
                if (b > c) {
                    c = b + (b=c, 0)
                    
                    if (a > b) {
                        a = b + (b=a, 0)
                    }
                }
                
                for (p of triplets[a]) {
                    if (p.b == b && p.c == c) {
                        return p;
                    }
                }
                if (generate) {
                    var n = {a:a,b:b,c:c};
                    triplets[a].push(n)
                    return n;
                } else
                    throw new Error("Triplet " + [a,b,c] + " not found.")
            }
            
            function getEdge(a,b) {
                if (a > b) {
                    a = b + (b=a, 0)
                }
                
                for (p of edges[a]) {
                    if (p.b == b) {
                        return p;
                    } 
                }
            }
            
            var latestID = 0;
            function createHex(centre) {
                if (latestID == 50) centre.y = 5
                
                var material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
                var mesh = new THREE.Mesh( debugGeometry, material );
                mesh.position.copy(centre);
                
                var hex = {id: latestID++, centre: centre, neighbours: [], neighboursData: [], debugModel: mesh, isHex:true};
                hexArray.push(hex);
                
                //scene.add(mesh)
                
                return hex;
            }
            
            function createTerrainGeometry() {
                var geometry = new THREE.BufferGeometry();
                var vertexArray = [];
                
                // Gather all Vector3 positions
                var vertices = []
                for (hex of hexArray) {
                    vertices.push(hex.centre);
                }
                
                var tri_offset = vertices.length;
                
                for (triplet of tripletArray) {
                    vertices.push(triplet.position);
                }
                
                // Convert to typed array of floats
                for (vertex of vertices) {
                    vertexArray.push(vertex.x, vertex.y, vertex.z);
                }
                vertexArray = new Float32Array(vertexArray);
                
                // Create faces
                var faceArray = [];
                for (hex of hexArray) {
                    var tri = [];
                    
                    for (var i  = 0; i < hex.neighbours.length; i++) {
                        var j = (i+1) % hex.neighbours.length;
                        tri.push(getTriplet(hex, hex.neighbours[i], hex.neighbours[j]));
                    }
                    
                    for (var i = 0; i < tri.length; i++) {
                        var j = (i+1) % tri.length;
                        
                        faceArray.push(hex.id, tri_offset+tri[j].id, tri_offset+tri[i].id);
                    }
                }
                
                
                geometry.setIndex( faceArray );
                
                geometry.setAttribute( 'position', new THREE.BufferAttribute( vertexArray, 3 ) );
                
                return geometry;
            }
            
            function createShape(hex, neighbours) {
                hex.neighbours = neighbours;
                for (neighbours of neighbours) {
                    cliff = false;
                    
                    if ( (hex.id + neighbours.id) % 5 == 1) {
                        cliff = true;
                    }
                    
                    hex.neighboursData.push({cliff: cliff});
                }
                var comb_geom = createGeometry(hex);
                
                var geometry = comb_geom[0];
                var material = new THREE.MeshPhongMaterial( { color: 0xffffff, side:THREE.DoubleSide } );
                var mesh = new THREE.Mesh( geometry, material );
                mesh.position.copy(hex.centre);
                //scene.add(mesh);
                
                var cliff_geometry = comb_geom[1];
                
                var material = new THREE.MeshPhongMaterial( { color: 0xffffff /*, side:THREE.DoubleSide*/ } );
                var mesh = new THREE.Mesh( cliff_geometry, material );
                mesh.position.copy(hex.centre);
                //scene.add(mesh);
            }
            
            function createGeometry(hex) {
                var geometry = new THREE.BufferGeometry();
                var cliffGeometry = new THREE.BufferGeometry();
                
                var edge_vertices = []
                for (var i = 0; i < hex.neighbours.length; i++) {
                    var j = (i+1) % hex.neighbours.length;
                    var vertex = new THREE.Vector3().addVectors(hex.neighbours[i].centre, hex.neighbours[j].centre).sub(hex.centre).sub(hex.centre).divideScalar(3);
                    
                    if (hex.neighboursData[i].cliff) {
                        var midVertex = new THREE.Vector3().copy(hex.neighbours[i].centre).sub(hex.centre).divideScalar(2);
                        
                        midVertex.y /= 2;
                        
                        midVertex.cliff = true;
                        midVertex.id = i;
                        
                        if (hex.neighboursData[j].cliff) {
                            vertex.cliff_edge = true;
                            vertex.y /= 2;
                        }
                        
                        edge_vertices.push(midVertex, vertex);
                    } else {
                        edge_vertices.push(vertex);
                    }
                }
                //console.log(edge_vertices);
                var vertices = [];
                var cliff_vertices = [];
                for (var i = 0; i < edge_vertices.length; i++) {
                    var j = (i+1) % edge_vertices.length;
                    
                    vertices.push(0,0,0);
                    vertices.push(...edge_vertices[i].toArray());
                    vertices.push(...edge_vertices[j].toArray());
                    
                    if (edge_vertices[j].cliff) {
                        var k = (i+2) % edge_vertices.length;
                        var neighbour_id = edge_vertices[j].id
                        if (hex.centre.y > hex.neighbours[neighbour_id].centre.y || true) {
                            var n = hex.neighbours.length;
                            var lowest = Math.min(hex.neighbours[(neighbour_id-1+n) % n].centre.y, hex.neighbours[neighbour_id].centre.y, hex.neighbours[(neighbour_id+1) % n].centre.y)
                            var drop = hex.centre.y - lowest;
                            
                            if (drop < 0)
                                drop = 1;
                            
                            cliff_vertices.push(...edge_vertices[i].toArray())
                            cliff_vertices.push(...edge_vertices[j].toArray())
                            cliff_vertices.push(edge_vertices[j].x, -drop, edge_vertices[j].z)
                            
                            cliff_vertices.push(...edge_vertices[j].toArray())
                            cliff_vertices.push(...edge_vertices[k].toArray())
                            cliff_vertices.push(edge_vertices[j].x, -drop, edge_vertices[j].z)
                            
                            if (edge_vertices[i].cliff_edge || true) {
                                cliff_vertices.push(...edge_vertices[i].toArray())
                                cliff_vertices.push(edge_vertices[j].x, -drop, edge_vertices[j].z)
                                cliff_vertices.push(edge_vertices[i].x, -drop, edge_vertices[i].z)
                            }
                            if (edge_vertices[k].cliff_edge || true) {
                                cliff_vertices.push(...edge_vertices[k].toArray())
                                cliff_vertices.push(edge_vertices[k].x, -drop, edge_vertices[k].z)
                                cliff_vertices.push(edge_vertices[j].x, -drop, edge_vertices[j].z)
                            }
                        }
                    }
                    
                    
                }
                vertices = new Float32Array(vertices);
                cliff_vertices = new Float32Array(cliff_vertices);
                
                geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
                geometry.computeVertexNormals();
                
                cliffGeometry.setAttribute( 'position', new THREE.BufferAttribute( cliff_vertices, 3 ) );
                cliffGeometry.computeVertexNormals();
                
                return [geometry, cliffGeometry];
            }
            
            function createGUI() {
                var gui = new dat.GUI();
            }
 
			var tick = 0
			function draw() {
                requestAnimationFrame(draw);
                
                stats.begin();
                tick += 1;
                
                camera.position.set(30*Math.sin(horAngle)*Math.sin(vertAngle), 30*Math.cos(vertAngle), 30*Math.cos(horAngle)*Math.sin(vertAngle) );
                camera.lookAt(lookAt);
                
                renderer.render( scene, camera );
                
                stats.end();
			}

		</script>

	</head>
	<body onload="onLoad()">
		<div id="myCanvasContainer"></div>
		<div id="statusContainer">
			<span>Test</span>
			<span>C1</span>
		</div>
	</body>
</html>